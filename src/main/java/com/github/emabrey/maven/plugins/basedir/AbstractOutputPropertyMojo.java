/*
 * The MIT License
 *
 * Copyright 2015 Emily Mabrey (emabrey@users.noreply.github.com).
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

package com.github.emabrey.maven.plugins.basedir;

import fj.F0;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.Properties;
import lombok.AccessLevel;
import lombok.Getter;
import org.apache.maven.plugin.AbstractMojo;
import org.apache.maven.plugin.MojoFailureException;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;
import org.apache.maven.project.MavenProject;


/**
 * An abstract Mojo which contains various basic features alongside the more specific feature of output to a Maven
 * and/or System property for the result of a goal's execution. The basic features include: logging configuration in the
 * form of a quiet option and a verbose option, access to the current project via an auto-populated unmodifiable
 * {@link MavenProject} handle, the ability to skip plugin execution, and the ability to execute a dry run that executes
 * a goal in a manner which is free of the side-effects of a standard execution.
 *
 * @author Emily Mabrey (emabrey@users.noreply.github.com)
 */
public abstract class AbstractOutputPropertyMojo extends AbstractMojo {
  
  /**
   * Read-only handle to the {@link MavenProject} which is currently executing this {@link Mojo}.
   */
  @Getter(AccessLevel.PROTECTED)
  @Parameter(defaultValue = "${project}", readonly = true)
  private MavenProject executingProject;
  
  /**
   * Limits the logging output of the execution of this goal, overriding other configured logging settings in such a way
   * that all non-essential messages are culled.
   */
  @Getter(AccessLevel.PROTECTED)
  @Parameter(defaultValue = "false")
  private boolean quiet;
  
  /**
   * Increases the logging output of the execution of this goal to include a high level of detail; note that this
   * configuration option is essentially the opposite of the "quiet" setting (also note that the quiet option overrules
   * the verbose option).
   */
  @Getter(AccessLevel.PROTECTED)
  @Parameter(defaultValue = "false")
  private boolean verbose;
  
  /**
   * Prevents the execution of the Mojo entirely, instead terminating the execution immediately if this option enabled.
   * Implementations of this class must respect this option by short-circuiting their execution implementation.
   */
  @Getter(AccessLevel.PROTECTED)
  @Parameter(defaultValue = "false", alias = "skip")
  private boolean executionSkipped;
  
  /**
   * Execute the Mojo normally excepting the generation of the output properties, which is skipped if this option is
   * enabled. This option for a dry run applies to the generation of Maven and System properties.
   */
  @Getter(AccessLevel.PROTECTED)
  @Parameter(defaultValue = "false")
  private boolean dryRun;
  
  /**
   * The name of the property to which the desired result will be outputted for later use within the POM. The given
   * property must be currently empty during the execution of the plugin goal because the plugin will generate an error
   * instead of overwriting a property value silently.
   */
  @Getter(AccessLevel.PROTECTED)
  @Parameter(defaultValue = "root.directory", required = true)
  private String outputProperty;
  
  /**
   * By enabling this option you can also generate a system property which is identical to the Maven project property
   * generated by default; note that the generated system property value will refuse to overwrite a preexisting value in
   * much the same way as the default Maven project property generation.
   */
  @Getter(AccessLevel.PROTECTED)
  @Parameter(defaultValue = "false", alias = "generateSystemProperty")
  private boolean systemPropertyEnabled;
  
  /**
   * Set the property value defined by {@link #outputProperty} to the given {@link CharSequence} value; optionally
   * setting both a Maven and System property if {@link #systemPropertyEnabled} is true (by default however, only a
   * Maven property is generated). If the properties are being modified instead of being created then this method will
   * generate an exception to prevent unintentional overwriting of property values.
   *
   * @param newValue
   *        The value which will be assigned to the property defined by {@link #outputProperty}.
   *
   * @throws MojoFailureException
   *         A non-fatal and potentially recoverable exception occurred while trying to generate an output property
   *         value.
   */
  protected void createOutputPropertiesWithoutAllowingOverwrites(final CharSequence newValue)
    throws MojoFailureException {
  
    try {
      setMavenPropertyValue(newValue);
      setSystemPropertyValue(newValue);
    }
    catch (final IllegalStateException ex) {
      throw new MojoFailureException("Unable to set property value(s)", ex);
    }
    
  }
  
  /**
   * Writes the given {@link CharSequence} to the {@link org.apache.maven.plugin.logging.Log} returned by
   * {@link #getLog()} if {@link #quiet} is false.
   *
   * @param message
   *        The message to be logged via {@link org.apache.maven.plugin.logging.Log#debug(CharSequence)}.
   */
  protected void writeDebugLogMessage(final CharSequence message) {
  
    if (!quiet) {
      getLog().info(message);
    }
  }
  
  /**
   * If {@link org.apache.maven.plugin.logging.Log#isInfoEnabled()} returns true then
   * {@link #writeDebugLogMessage(CharSequence)} is called with the result of the provided {@link CharSequence}
   * producing {@link F0}. This function is provided as a more efficient option that avoids the cost of generating a
   * {@link CharSequence} which ends up being unused.
   * 
   * @param messageProducer
   *        A 0 argument function which is used to produce a {@link CharSequence} if needed.
   */
  protected void writeDebugLogMessage(final F0<CharSequence> messageProducer) {
  
    if (getLog().isInfoEnabled()) {
      writeDebugLogMessage(messageProducer.f());
    }
  }
  
  /**
   * Writes the given {@link CharSequence} to the {@link org.apache.maven.plugin.logging.Log} returned by
   * {@link #getLog()} if {@link #quiet} is false, {@link #verbose} is true..
   *
   * @param message
   *        The message to be logged via {@link org.apache.maven.plugin.logging.Log#debug(CharSequence)}.
   */
  protected void writeTraceLogMessage(final CharSequence message) {
  
    if (!quiet && verbose) {
      getLog().debug(message);
    }
  }
  
  /**
   * If {@link org.apache.maven.plugin.logging.Log#isDebugEnabled()} returns true then
   * {@link #writeTraceLogMessage(CharSequence)} is called with the result of the provided {@link CharSequence}
   * producing {@link F0}. This function is provided as a more efficient option that avoids the cost of generating a
   * {@link CharSequence} which ends up being unused.
   * 
   * @param messageProducer
   *        A 0 argument function which is used to produce a {@link CharSequence} if needed.
   */
  protected void writeTraceLogMessage(final F0<CharSequence> messageProducer) {
  
    if (getLog().isDebugEnabled()) {
      writeTraceLogMessage(messageProducer.f());
    }
  }
  
  /**
   * Assigns the given {@link CharSequence} value to a Maven property defined by {@link #outputProperty} after verifying
   * that the selected property does not already have a preexisting value (an exception prevents a silent overwrite).
   *
   * @param newValue
   *        The value which will be assigned to the Maven property defined by {@link #outputProperty}.
   *
   * @throws IllegalStateException
   *         The call to {@link #setPropertyValue(Properties, String)} was unable to overwrite a preexisting property
   *         value.
   */
  private void setMavenPropertyValue(final CharSequence newValue) throws IllegalStateException {
  
    writeDebugLogMessage("Attempting to write value to Maven property " + outputProperty);
    setPropertyValue(executingProject.getProperties(), newValue.toString());
  }
  
  /**
   * Assigns the given {@link CharSequence} value to a System property defined by {@link #outputProperty} after
   * verifying that {@link #generateSystemProperty} is true and that the selected property does not already have a
   * preexisting value (an exception prevents a silent overwrite).
   *
   * @param newValue
   *        The value which will be assigned to the System property defined by {@link #outputProperty}.
   *
   * @throws IllegalStateException
   *         The call to {@link #setPropertyValue(Properties, String)} was unable to overwrite a preexisting property
   *         value.
   */
  private void setSystemPropertyValue(final CharSequence newValue) throws IllegalStateException {
  
    if (isSystemPropertyEnabled()) {
      
      writeDebugLogMessage("Attempting to write value to System property " + outputProperty);
      setPropertyValue(System.getProperties(), newValue.toString());
    }
  }
  
  /**
   * Adds a property to the given {@link Properties} object whose key is {@link #outputProperty} and whose value is the
   * given String; this method will generate an exception if the selected output property already exists, to prevent
   * silent overwriting. This method respects the dry run setting returned by {@link #isDryRun()} and will avoid the
   * final output to the given {@link Properties} object if this execution is a dry run.
   *
   * @param propertiesCollection
   *        The {@link Properties} object which will be modified by the addition of a new property value if this is not
   *        a dry run.
   * @param newValue
   *        The {@link String} value of the property value which will be created.
   *
   * @throws IllegalStateException
   *         The output property has a preexisting value which is not allowed; clear the value of the property manually
   *         if an overwrite is needed.
   */
  private void setPropertyValue(final Properties propertiesCollection, final String newValue)
    throws IllegalStateException {
  
    final boolean outputPropertyDNE = !propertiesCollection.containsKey(outputProperty);
    
    if (outputPropertyDNE) {
      if (isDryRun()) {
        writeDebugLogMessage("Skipping property output because this is a dry run");
      }
      else {
        propertiesCollection.setProperty(outputProperty, newValue);
        writePropertiesLogMessage(propertiesCollection);
      }
    }
    else {
      writeTraceLogMessage("Unable to set property value because a property using that key already exists");
      throw new IllegalStateException(
        "The selected Maven or System property for outputting the goal results must not exist");
    }
  }
  
  /**
   * Generates a trace level log output delineating the contents of the given {@link Properties} object.
   *
   * @param properties
   *        The {@link Properties} object to be used to generate a log output.
   */
  private void writePropertiesLogMessage(final Properties properties) {
  
    if (!quiet) {
      writeTraceLogMessage(() -> getPropertiesListAsString(properties));
    }
  }
  
  /**
   * Generates a trimmed {@link String} populated with the list of property values obtained from the given
   * {@link Properties} object.
   *
   * @param properties
   *        A {@link Properties} object.
   * @return A {@link String} containing the formatted list of properties.
   */
  private String getPropertiesListAsString(final Properties properties) {
  
    final StringWriter stringWriter = new StringWriter();
    properties.list(new PrintWriter(stringWriter));
    
    final StringBuffer resultBuffer = stringWriter.getBuffer();
    resultBuffer.trimToSize();
    return resultBuffer.toString();
  }
}
